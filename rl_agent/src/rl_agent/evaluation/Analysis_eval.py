'''
    @name:      Analysis_eval.py
    @brief:     The class can be used to analyse the produced evaluation_data generated by Evaluation.py
    @author:    Ronja Gueldenring
    @version:   3.5
    @date:      2019/04/05
'''

import rospkg
import pickle
import math
import csv

class Analysis():
    def __init__(self):
        rospack = rospkg.RosPack()
        self.__rl_agent_path = rospack.get_path('rl_agent')         # absolute path rl_agent-package

    def load_results(self, filename):
        results = []
        with open('%s.pickle'%(filename), 'rb') as fr:
            try:
                while True:
                    d = pickle.load(fr)
                    results.append(d)
            except EOFError:
                pass
        return results

    def get_timestep_list(self, results):
        timesteps = []
        for result in results:
            timesteps.append(result["timestep"])

        return timesteps

    def reconstruct_timestep_array(self, timesteps):
        previous_ts = timesteps[0]
        break_indices = []

        for i, ts in enumerate(timesteps):
            if (previous_ts - ts) >1000:
                break_indices.append(i)
            previous_ts = ts

        break_indices.append((len(timesteps)))
        for k in range(len(break_indices)-1):
            base_timestep = timesteps[break_indices[k]-1]
            for j in range(break_indices[k], break_indices[k+1]):
                timesteps[j] = base_timestep + timesteps[j]

        return timesteps





    def get_scores(self, results):
        """
        Analyses the success rate for all n episodes in results.
        :param results: list of n results
        :returns: success-rate, time_exceeded-rate, collision-rate (all lists)
        """
        success_vec = []
        time_exceeded_vec = []
        collision_vec = []

        for i in range(0, len(results)):
            exit = results[i]["success"]
            collision = 0
            time_exceeded = 0
            success = 0
            if exit == -1:
                collision = 1
            elif exit == 0:
                time_exceeded = 1
            elif exit == 1:
                success = 1

            success_vec.append(success)
            time_exceeded_vec.append(time_exceeded)
            collision_vec.append(collision)
            
        return success_vec, time_exceeded_vec, collision_vec


    def get_percentual_success_drive(self, results):
        """
        Computes the percentage of successful path following for each episode
        :param results: list of n results
        :return list of percentages of successful path following
        """
        percentage_vec = []
        for result in results:
            if len(result["global_path"].poses) == 0:
                percentage_vec.append(1)
            else:
                if result["success"] == 1:
                    percentage_vec.append(1)

                else:
                    i = self.__closest_path_pos(result["global_path"], result["driven_path"].poses[-1].pose)
                    percentage_vec.append(i / len(result["global_path"].poses))
        return percentage_vec

    def get_path_length_ratio(self, results):
        """
        Computes the path length ratio (driven path/global path)
        :param results: list of n results
        :return  list of the path length ratios
        """
        path_length_ratio_vec = []
        for result in results:
            if len(result["global_path"].poses) == 0:
                path_length_ratio_vec.append(1)
            else:
                i = len(result["global_path"].poses)
                if result["success"] != 1:
                    i = self.__closest_path_pos(result["global_path"], result["driven_path"].poses[-1].pose)
                global_path_length = self.__get_path_length(result["global_path"].poses[:i])
                driven_path_length = self.__get_path_length(result["driven_path"].poses)
                if global_path_length <= 0:
                    path_length_ratio_vec.append(1)
                else:
                    path_length_ratio_vec.append(driven_path_length/global_path_length)

        return path_length_ratio_vec

    def get_speed(self, results):
        """
        Computes the average speed for each episode
        :param results: list of n results
        :return  list of the average speed
        """
        speed_vec = []
        for result in results:
            if len(result["global_path"].poses) == 0:
                speed_vec.append(1.0)
            else:
                i = len(result["global_path"].poses)
                if (result["success"] != 1):
                    i = self.__closest_path_pos(result["global_path"], result["driven_path"].poses[-1].pose)
                path_length = self.__get_path_length(result["global_path"].poses[:i])
                speed = path_length/result["time"].to_sec()
                # Handling outliers
                if (speed > 1.0):
                    speed_vec.append(1.0)
                else:
                    speed_vec.append(path_length/result["time"].to_sec())
        return speed_vec

    def get_reward(self, filename):
        """
        Getter for the reward for each episode
        :param results: list of n results
        :param filename: filename of the .csv-file, where the reward is saved.
        :return  list of the rewards
        """
        timesteps = []
        reward = []
        line_count = 0
        with open('%s.csv'%(filename), 'r') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')

            for row in reader:
                if (line_count == 0):
                    line_count += 1
                    continue
                timesteps.append(float(row[1]))
                reward.append(float(row[2]))

        return [timesteps, reward]

    def __closest_path_pos(self, path, pose):
        """
        Computes the path_pose on the path that is closest to pose
        :param path
        :param pose
        :return  path_pose
        """
        index = 0
        count = 0
        dist = 10
        for path_pose in path.poses:
            temp_dist = self.__mean_square_dist((pose.position.x - path_pose.pose.position.x),
                                                (pose.position.y - path_pose.pose.position.y))
            if (temp_dist < dist):
                dist = temp_dist
                index = count
            count += 1

        if (dist > 3):
            index = 0
        return index

    def __mean_square_dist(self, x, y):
        """
        Computes the mean-square distance
         :param x
         :param y
         :return  sqrt(x^2 + y^2)
         """
        return math.sqrt(math.pow(x, 2) + math.pow(y, 2))


    def __get_path_length(self, poses):
        """
        Computes the length of a path
         :param poses: poses on the path
         :return  length of the path
         """
        if len(poses) <= 1:
            return 0
        path_length = 0
        old_pose =poses[0].pose.position
        for pose in poses[1:]:
            new_pose = pose.pose.position
            path_length += self.__mean_square_dist((new_pose.x - old_pose.x), (new_pose.y - old_pose.y))
            old_pose = new_pose
        return path_length


